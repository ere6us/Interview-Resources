# Operating Systems
I really like these [Notes](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/) but [GeeksforGeeks](https://www.geeksforgeeks.org/operating-systems/) is also great.

## [Process](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/3_Processes.html)
Checklist:
+ Process
+ Process State
+ PCB
+ Process Scheduling
+ Schedulers
+ Context switch
+ Process creation
+ Process termination
+ Zombie and orphan processes
+ Interprocess Communication
+ Shared memory
+ Pipes

## Events
+ Hardware interrupts
  - raised by hardware
  - are asyncronous and can occur anytime
+ Traps
  - Software interrupts
  - raised by user programs, to invoke OS functionality.
+ Exceptions
  - generated by processor itself as a result of an illegal function
  - faults: recoverable errors(pagefault)
  - aborts: difficult to recover (divide by 0)
+ Interrupt handling

## [Threads](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)
+ What is thread?
+ Difference between thread and process.
+ Benefits of multitherading
+ Types of parallelism
+ Multithreading models
+ Types of threads

## [Syncronization](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/5_Synchronization.html)
+ The critical section problem
  - Mutual exclusion
  - Progress
  - Bounded wait.
+ Types of kernels.
+ Peterson's solution
```cpp
  do {
    flag[i] = true;
    turn = j; // atomic instruction
    while (flag[j] and turn == j);
    // critical section
    flag[i] = false;
    // remainder section
  } while (true);
```
+ Test and Set.
```cpp
  // executed atomically
  bool TestAndSet(bool *target) {
    bool rv = *target;
    *target = true;
    return rv;
  }
  
  do {
    while (TestAndSet(&lock));
    // critical section
    lock = false;
    // remainder section
  } while (true);
```
Mutual Exclusion is satisfied but bounded wait is not guaranteed.

+ Mutex locks
```cpp
 do {
  acquire_lock()
  critical section
  release_lock()
  remainder section
 } while (true);
 // atomic
 acquire_lock() {
  while (!available);
  availabe = false;
 }
 // atomic
 release_lock() {
  available = true;
 }
```
+ Semaphores
```cpp
  // atomic
  wait(s) {
    while (s <= 0);
    s--;
  }
  signal(s) {
    s++;
  }
```
  - Binary semaphores
  - Counting semaphores

  - The big problem with semaphores is the busy loop in the wait call, i.e. the spin lock.
  - An alternative approach is to block a process when it is forced to wait for an available
    semaphore, and swap it out of the CPU. In this implementation each semaphore needs to maintain
    a list of processes that are blocked waiting for it, so that one of the processes can be
    woken up and swapped back in when the semaphore becomes available.
+ Monitors

## [Deadlocks](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/7_Deadlocks.html)
+ Conditions for deadlocks.
+ Handling deadlocks
  - avoidance
  - detection and recovery
  - ignorance
+ bankers algorithm

## [Scheduling](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/6_CPU_Scheduling.html)
+ CPU Burst vs I/O Burst
+ Preemptive vs non-preemptive scheduling
+ Dispatcher
+ Scheduling Criteria
    - CPU Utilization (maximize)
    - Throughput (maximize)
    - Turnaround time (minimize)
    - Waiting time (minimize)
    - Response time (minimize)
+ Scheduling Algorithms
  - First come first serve
  - Shortest job first
  - Priority
  - Round Robin
  - Multilevel Queue
  - Multilevel Feedback Queue
+ Multiprocessor Scheduling
    - heterogeneous vs homogeneous processors
    - symmetric vs asymmetric multiprocessing
    - processor affinity
    - load balancing
      + push migration
      + pull migration

## Memory Management
+ Single contiguous model
+ Partition model
+ Virtual Memory
+ fragmentatino and internal fragmentation
+ TLD Cache
+ Demand paging
+ Memory mapping
+ Multilevel page translation
+ shared pages
+ hashed page tables
+ inverted page tables
+ segmentation (logical address to linear address)
## Questions
+ preemptive vs non-preemptive kernels.
+ [Difference between mutex and semaphore](https://www.geeksforgeeks.org/mutex-vs-semaphore/)
+ belady's anomaly
+ Types of OS
+ paging problems
+ thrashing
+ TLB and Effective access time.
+ standard semaphore problems.
+ preemptive vs non-preemptive kernels.
+ Threads vs processes
